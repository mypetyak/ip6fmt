use std::io;
use std::net::Ipv6Addr;
use std::str::FromStr;

fn replace_ip(line: &mut String, left: usize, right: usize) {
    match Ipv6Addr::from_str(&line[left..right + 1]) {
        Ok(v) => {
            //line.replace_range(left..right+1, &v.to_string()[..]);
            line.replace_range(left..right + 1, &explode_ip(&v)[..]);
        }
        Err(_) => (),
    };
}

fn explode_ip(ip: &Ipv6Addr) -> String {
    //let s = ip.to_string();
    //let s = match String::from_utf16(&[2, 34, 111]) {
    //let s = match String::from_utf16(&ip.segments()) {
    //    Ok(v) => v,
    //    Err(_) => panic!("foo"),
    //};
    //s
    //
    //
    match ip.segments() {
        [a, b, c, d, e, f, g, h] => format!("{:0>4x}:{:0>4x}:{:0>4x}:{:0>4x}:{:0>4x}:{:0>4x}:{:0>4x}:{:0>4x}",
            a, b, c, d, e, f, g, h
        ),
    }
    //
    //let mut s = String::new();

    //for seq in &ip.segments() {
    //    s.push_str(format!("{:x}", seq));
    //}
    //s
    ////ip.to_string()[..]
}

fn main() {
    let mut s = String::new();

    io::stdin().read_line(&mut s).expect("Failed to read line");

    let mut sentence = s.clone();

    let mut left: usize = 0;
    let mut right: usize = 0;
    let mut inword: bool = false;

    for tup in s.char_indices().rev() {
        match tup {
            (idx, '0'..='9') | (idx, 'a'..='f') | (idx, ':') => {
                if !inword {
                    inword = true;
                    right = idx;
                }
                left = idx;
            }
            _ => {
                if inword {
                    replace_ip(&mut sentence, left, right);
                }
                inword = false;
            }
        }
    }
    if inword {
        replace_ip(&mut sentence, left, right);
    }
    println!("{}", sentence);
}
